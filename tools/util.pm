#!/usr/bin/perl -w

## util.pm

#############################
#                           #
#  FITS Specific Utilities  #
#                           #
#############################

# Compute the firing time for a group of fireflies
#
# input:  list of times
# output: group's firing time
# param:  OPTIONAL grouping function: begin, end, avg or average
#
# notes: if the first parameter is anything besides
#        begin or end we use average
#        if the first parameter is a number it is included
#        in the computation
#
sub group_fire_time {
    my ($op) = shift @_;

    if ( $op =~ /begin/i ) {
        return &min( @_ );
    } elsif ( $op =~ /end/i ) {
        return &max( @_ );
    }

    # no begin or end -- so it's average

    # is $op a number?
    # if yes include it in the average

    if ( $op =~ /avg/ ) {
    } elsif ( $op =~ /average/ ) {
    } elsif ( $op =~ /[A-Za-z]/ ) {
      warn "ignoring unsupported operator $op";
    } else {
      unshift @_, $op;
    }

    return &average(@_);
}

# Extract motes from a group entry
#
# input:  one line of output from data generated by processGroups.pl
# output: list of motes in this entry
#
sub motes_from_group {
  my ($line, @entry, @groups, @motes, @group_entry);

  $line = $_[0];
  chomp( $line );

  @entry = split(/\t/,$line);

  if ( 3 > @entry ) {
    return ();
  }

  @groups = split(/\)\,\(/,$entry[3]);

  foreach ( @groups ) {
    $_ =~ s/\(//;
    $_ =~ s/\)\,//;

    @group_entry = split(/\,\ /,$_);

    if ( defined $group_entry[0] ) {
      push @motes, $group_entry[0];
    }
  }

  return @motes;
}

# Extract sequence numbers from a group entry
#
# input:  one line of output from data generated by processGroups.pl
# output: list of sequence numbers
#
sub seqno_from_group {
  my ($line, @entry, @groups, @seqno, @group_entry);

  $line = $_[0];
  chomp( $line );

  @entry = split(/\t/,$line);

  if ( 3 > @entry ) {
    return ();
  }

  @groups = split(/\)\,\(/,$entry[3]);

  foreach ( @groups ) {
    $_ =~ s/\(//;
    $_ =~ s/\)\,//;

    @group_entry = split(/\,\ /,$_);

    if ( defined $group_entry[1] ) {
      push @seqno, $group_entry[1];
    }
  }

  return @seqno;
}


# Extract time data from a group entry
#
# input:  one line of output from data generated by processGroups.pl
# output: list of times
#
sub times_from_group {
  my ($line, @entry, @groups, @times, @group_entry);

  $line = $_[0];
  chomp( $line );

  @entry = split(/\t/,$line);

  if ( 3 > @entry ) {
    return ();
  }

  @groups = split(/\)\,\(/,$entry[3]);

  foreach ( @groups ) {
    $_ =~ s/\(//;
    $_ =~ s/\)\,//;

    @group_entry = split(/\,\ /,$_);

    if ( defined $group_entry[2] ) {
      push @times, $group_entry[2];
    }
  }

  return @times;
}

# Hack to compute number of motes
#
# input: file name
# output: sorted list of unique motes
#
sub unique_motes {
  my ($uniqSourceaddr, $filename);

  $filename = $_[0];

  if ($filename =~ /gz$/) {
    $uniqSourceaddr = `zcat $filename | grep -o -P ^[0-9]+ | sort | uniq`;
  } else {
    $uniqSourceaddr = `grep -o -P ^[0-9]+ $filename | sort | uniq`;
  }
  chomp $uniqSourceaddr;
  my @sourceAddrs = split(/\s/, $uniqSourceaddr);

  return @sourceAddrs;
}

#######################
#                     #
#  General Utilities  #
#                     #
#######################

# Return the max of a list of values
# taken from the Lama book
sub max {
    my ($max) = shift @_;

    foreach ( @_ ) {
        if ( $_ > $max ) {
            $max = $_;
        }
    }

    return $max;
}

# Return the min of a list of values
sub min {
    my ($min) = shift @_;

    foreach ( @_ ) {
        if ( $_ < $min ) {
            $min = $_
        }
    }

    return $min;
}

# compute the average from a list of values
sub average {
    my $total = 0;

    foreach ( @_ ) {
      $total += $_;
    }

    return $total / @_;
}

# Description: Computes the standard deviation of a bunch of numbers
# Usage:       ./stdev.pl <inputfile>
#              <input file> can have numbers in any order on multiple lines

# Input:  A row of numbers
# Output: Std. Dev value

sub stdev {
    my @numbers = @_;

    if ($#numbers == 0) {       
## Only 1 number?
        print "Not Enough information to calculate a\n";
        print "standard deviation\n\n"; 
        exit;
    }
#print "Read $#numbers+1 numbers: @numbers \n";

# Use the Perl module
#my $stddev = new Statistics::Basic::StdDev(\@numbers);
#print "Stdev (computed from Perl Module) = ", $stddev->query, "\n";

###############################
#                             #
#  Compute Std. Dev. manually #
#                             #
###############################

## Calculate the average                                                                                             

    my $average = average(@numbers); 
    #print "The average is $average\n";

## Calculate the standard deviation 

    my $stddev = 0;
    for $n (@numbers) {
        $stddev = $stddev + ($n - $average) ** 2;
    }
    $stddev = sqrt($stddev / $#numbers);

    #print "The Standard Deviation (computed manually): ";
    #print "$stddev\n";

    return $stddev;
}

1;    # use'd files have to return true!
